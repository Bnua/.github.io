<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python可视化神器-plotly]]></title>
    <url>%2F2019%2F02%2F18%2F1%2F</url>
    <content type="text"><![CDATA[本文是浏览 medium 时发现的，这篇文章可以让我们认识到 plotly 的存在使数据可视化分析操作更加简易，交互性更强，效率更高。** 原文链接The Next Level of Data Visualization in Python** ** 数据来源: medium数据 ** ** 注:原文需翻墙，所以进行了转载翻译 ** plotly简介plotly是一款基于D3.js框架的Python库，Plotly中绘制图像有在线和离线两种方式，因为在线绘图需要注册账号获取API key，较为麻烦，所以本文仅介绍离线绘图的方式。离线绘图又有plotly.offline.plot()和plotly.offline.iplot()两种方法，前者是以离线的方式在当前工作目录下生成html格式的图像文件，并自动打开；后者是在jupyter notebook中专用的方法，即将生成的图形嵌入到ipynb文件中。文中的所有工作都是使用 plotly + cufflinks 在Jupyter笔记本中离线运行完成。 用 pip 安装 plotly 和 cufflinks，在 jupyter 导入 cufflinks plotly 运行： 12345678# 导入 plotlyimport plotly.plotly as pyimport plotly.graph_objs as gofrom plotly.offline import iplot, init_notebook_mode# 在离线模式下使用 cufflinks plotlyimport cufflinkscufflinks.go_offline(connected=True)init_notebook_mode(connected=True) 单变量分布：柱状图和箱线图12df[&apos;claps&apos;].iplot(kind=&apos;hist&apos;, xTitle=&apos;claps&apos;, yTitle=&apos;count&apos;, title=&apos;Claps Distribution&apos;) 相比较那些习惯 matplotlib，我们所要做的就是再添加一个字母 i (iplot），就可以得到一个交互式更强的图表，我们可以点击数据来获取更多细节，放大图的各个部分，选择显示不同的类别。 如果我们需要柱状图重叠效果，那也是非常的简单： 1234567df[[&apos;time_started&apos;, &apos;time_published&apos;]].iplot( kind=&apos;hist&apos;, histnorm=&apos;percent&apos;, barmode=&apos;overlay&apos;, xTitle=&apos;Time of Day&apos;, yTitle=&apos;(%) of Articles&apos;, title=&apos;Time Started and Time Published&apos;) 只需要简单操作一下 pandas ，我们就可以绘制条形图： 123456＃重新采样到每月频率并绘制df2 = df[[&apos;view&apos;,&apos;reads&apos;,&apos;published_date&apos;]].\ set_index(&apos;published_date&apos;).\ resample(&apos;M&apos;).mean()df2.iplot(kind=&apos;bar&apos;, xTitle=&apos;Date&apos;, yTitle=&apos;Average&apos;, title=&apos;Monthly Average Views and Reads&apos;)） 我们可以用 pandas + plotly + cufflink。对于不同的粉丝数量来进行箱线图的绘制: 1234df.pivot(columns=&apos;publication&apos;, values=&apos;fans&apos;).iplot( kind=&apos;box&apos;, yTitle=&apos;fans&apos;, title=&apos;Fans Distribution by Publication&apos;) 箱线图中有很多信息，如果看不到数字我们会错失很多东西，交互性的好处就在于此，我们根据自己的需求来展示对应的数据。 散点图它将所有的数据以点的形式展现在直角坐标系上，以显示变量之间的相互影响程度，点的位置由变量的数值决定。通过观察散点图上数据点的分布情况，我们可以推断出变量间的相关性。如果变量之间不存在相互关系，那么在散点图上就会表现为随机分布的离散的点，如果存在某种相关性，那么大部分的数据点就会相对密集并以某种趋势呈现。数据的相关关系主要分为：正相关（两个变量值同时增长）、负相关（一个变量值增加另一个变量值下降）、不相关、线性相关、指数相关等。 时间序列时间序列（或称动态数列）是指将同一统计指标的数值按其发生的时间先后顺序排列而成的数列。时间序列分析的主要目的是根据已有的历史数据对未来进行预测。下边让我们制作一片关于我的 TDS 文章的数据框，看看趋势是如何变化的。 1234567tds = df[df[&apos;publication&apos;] == &apos;Towards Data Science&apos;].\ set_index(&apos;published_date&apos;)# 绘制时间序列图tds[[&apos;claps&apos;, &apos;fans&apos;, &apos;title&apos;]].iplot( y=&apos;claps&apos;, mode=&apos;lines+markers&apos;, secondary_y = &apos;fans&apos;, secondary_y_title=&apos;Fans&apos;, xTitle=&apos;Date&apos;, yTitle=&apos;Claps&apos;, text=&apos;title&apos;, title=&apos;Fans and Claps over Time&apos;) 在这一行中我们做了很多事情： 自动生成合适的时间序列x轴 因为变量的范围有所不同，所以我们添加了辅助 Y 轴 添加文章标题作为悬停信息我们还可以添加更加详细的文本注释：12345678tds_monthly_totals.iplot( mode=&apos;lines+markers+text&apos;, text=text, y=&apos;word_count&apos;, opacity=0.8, xTitle=&apos;Date&apos;, yTitle=&apos;Word Count&apos;, title=&apos;Total Word Count by Month&apos;) 对于由第三个分类变量着色的双变量散点图，我们使用： 12345678df.iplot( x=&apos;read_time&apos;, y=&apos;read_ratio&apos;, # Specify the category categories=&apos;publication&apos;, xTitle=&apos;Read Time&apos;, yTitle=&apos;Reading Percent&apos;, title=&apos;Reading Percent vs Read Ratio by Publication&apos;) 数据可视化进阶现在，我们将讨论一些您可能不会经常使用的情节，但这些情节可能会令人印象深刻。 散射矩阵当我们想探索多个变量之间的关系时，散射矩阵（也称为SPLOM）是一个很好的选择： 123456import plotly.figure_factory as fffigure = ff.create_scatterplotmatrix( df[[&apos;claps&apos;, &apos;publication&apos;, &apos;views&apos;, &apos;read_ratio&apos;,&apos;word_count&apos;]], diag=&apos;histogram&apos;, index=&apos;publication&apos;) 这些图都是完全的交互式，可以让我们查看任何想知道的数据。 热力图为了可视化数值变量之间的相关性，我们计算相关性，然后制作一个带注释的热力图： 1234567corrs = df.corr()figure = ff.create_annotated_heatmap( z=corrs.values, x=list(corrs.columns), y=list(corrs.index), annotation_text=corrs.round(2).values, showscale=True) Cufflinks 也有几个主题，我们可以选自己中意的风格。例如： 我们也可以得到3D图形： 结论我们在看完这些演示后就明白了我们在以往的绘图过程中浪费了多少时间精力。到目前为止，在Python中执行所有这些操作的最佳选择是plotly。Plotly允许我们快速地进行可视化，并通过交互帮助我们更好地洞察数据。]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统中的数据挖掘方法]]></title>
    <url>%2F2018%2F07%2F14%2F1%2F</url>
    <content type="text"><![CDATA[1. 推荐系统中的数据挖掘方法概览&emsp;&emsp;数据挖掘过程一般是由三个连续的执行步骤组成，本章不会过多的介绍这些方法，只是做一个总结，详细的过程以及公式推导建议大家去阅读《统计学方法》以及《推荐系统 技术、评估及高效算法》。。]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于内容的语义感知系统]]></title>
    <url>%2F2018%2F07%2F04%2F1%2F</url>
    <content type="text"><![CDATA[1. 基于内容的推荐系统&emsp;&emsp;基于内容的推荐系统依赖物品和用户描述内容来构建其特征表示，然后基于这些特征表示推荐与目标用户曾明确表达过喜好的物品相类似的物品。该类推荐系统的基本过程是对目标用户属性(偏好，兴趣)与物品属性进行匹配，并返回目标用户在物品上的喜好程度。&emsp;&emsp;CRRS（基于内容的推荐系统）的高层次架构图如下，推荐的过程有三个阶段。每一个阶段由独立的部件控制。 内容分析器：当信息没有结构化时（如文本），某些预处理阶段需要抽取相关的结构化信息。这个部件的主要功能就是将来自信息源的对象（如文档、网页、新闻、产品描述等）的内容表示成恰当的格式，以便于下一阶段的处理。数据对象经过特征抽取技术的分析，目的是将原始信息空间转换到想要的物品描述格式（如将网页表示成关键词向量）。这样的描述格式作为信息学习器和过滤组件的输入。 信息学习器：这个模块收集了有关用户偏好的数据特征，并试图去泛化这些数据，从而构建用户特征信息。泛化策略通常是通过机器学习技术实现的，它可以从用户过去喜欢的或不喜欢的物品中推断出一个用户的兴趣模型。例如，网页推荐的信息学习器可以实现相关的反馈方法，通过学习技术将正负样例向量组合到一个表示用户特征的模型向量中。训练样本是由用户提供的具有正负反馈的网页。 过滤组件：这个模块将用户个人信息和物品在表示空间进行匹配，利用用户个人信息来推荐相关物品。这个组件的结果是一个二元的或者连续型的相关性判断（使用某种相似度来计算），后者能生成一个潜在感兴趣物品的排名清单。在上面提过的例子中，这种匹配是通过计算原型向量和物品向量的余弦相似度得到的。 &emsp;&emsp;推荐步骤的第一个阶段是由内容分析器完成的，它通常是借鉴了信息检索系统的技术。来自信息源的物品描述经过内容分析器，从非结构化的文本中抽取特征（如关键词、n-grams、概念等），从而得到结构化的物品描述，并储存在被表示物品库中。&emsp;&emsp;为了结构化和更新活跃用户Ua(必须为其提供推荐的用户)的个人信息，该用户对物品的偏好反应是通过某些渠道收集并记录在反馈库中的。这些被称作注释或反馈的相互作用和物品的相关描述一起被用在模型学习的过程中，这些信息对实际中预测新的相关物品的表示非常有用。因此，即使没有提供任何反馈，用户也可以清晰地定义他们自己感兴趣的领域作为初始的个人信息。&emsp;&emsp;通常情况下，我们能够区分这两种类型的相关性反馈：正面的信息（用户喜欢的特征）和负面的信息（用户不感兴趣的特征）。两种不同的技术都能用来记录用户的反馈。当系统要求用户明确评价物品时，这项技术通常称作“显式反馈”；反之，则称作“隐式反馈”，由于反馈来自监控和分析用户的行为，所以它不需要任何活跃用户的参与。确切的评价能够表明用户对一个物品相关或感兴趣的程度。主要有三种方式来得到显式的相关性反馈： 喜欢/不喜欢：利用一个简单的二元化评分刻度，将物品分成“相关的”或“不相关的”两大类。 评分：经常用来评价物品的一个离散的数值刻度，详情参见文献。当然，标记化的评价也可以映射到数值刻度，如在Syskill&amp;Webert中一样，把用户对网页的评价划分为热门、一般、冷门。 评论：收集并展示单一物品的评论给用户，使其成为用户加快决策过程的一种方式。例如，在Amazon或eBay上，用户的反馈可以帮助其他用户判断一件物品是否被大众所接受。文本评论是有益的，但是这些评论也会对用户造成负担，因为她必须阅读和理解每条评论，并决定哪些评论是正面的哪些是负面的，以及这些评论的程度。文献从情感计算研究领域中提出的先进技术，使得基于内容的推荐系统能够自动执行这种分析。 1. 基于内容的推荐系统基于内容的推荐与基于协同过滤的推荐相比有以下优点： 用户独立性：基于内容的推荐仅使用当前用户提供的评分来构建自己的个人信息。而协同过滤的方法需要其他用户的评分，来发现该用户最近的近邻，例如，由于对相同的物品评分相似而品味相似的用户。这时，只有当前用户最近邻很喜欢的物品才有可能推荐给当前用户。 透明度：通过显式地列出使得物品出现在推荐列表中的内容特征或描述，可以解释推荐系统是如何工作的。这些物品特征是决定是否信任该推荐的指标。相反，协同过滤系统是一个黑盒子，对一个推荐物品的唯一解释是相似品味的未知用户喜欢过该物品。 新物品：基于内容的推荐系统在没有任何用户评分的情况下也可以进行推荐。因此，新物品没有第一次评分会影响协同过滤推荐系统，因为协同过滤推荐系统仅依赖于用户的偏好产生推荐。所以只有当一个新物品被一系列用户评分之后，系统才可能推荐它。尽管如此，基于内容的推荐系统也有以下一些缺点： 可分析的内容有限：基于内容的推荐技术有一个天然的限制，即与推荐对象相关的特征数量和类型上的限制，不管是自动还是手动的。领域知识一般是必需的，例如，对于电影推荐，系统需要知道电影的演员、导演，有时候领域本体也是需要的。当分析的物品内容信息不足以区分哪些物品是用户喜欢的、哪些物品是用户不喜欢的时候，没有任何基于内容的推荐系统可以给出合适的推荐。有些解释只能获取物品内容的某些方面，但是还有很多别的方面也能影响用户体验。举个例子，在玩笑或者诗词里，没有足够的词频信息去为用户兴趣建模，这时，情感计算的技术就会更适用。此外，对于网页来说，文本特征抽取技术完全忽略其美学特征和附加的多媒体信息。总之，不论是手动还是自动为物品分配特征，都不足以定义物品不同的特点，而这些特点被证明对提取出用户兴趣是必要的。 过度特化：基于内容的推荐在本质上无法发现一些出人意料的物品。系统建议的物品和用户的个人信息高度匹配的时候，给用户的推荐也将会是与已有的评分物品相似的物品。这个缺点主要是由于基于内容的系统产生的推荐物品在新颖性上的缺陷，称作惊喜度问题。举例来说，当一个用户只评价了Stanley Kubrick导演的电影，那么她得到的推荐就只有这种类型的电影。一个“完美”的基于内容的技术可能很少发现任何新颖的东西，这限制了使用它的应用程序的范围。 新用户：在一个基于内容的推荐系统可以真正理解用户偏好且给出准确的推荐之前，需要收集足够的评分。因此，当只有很少的评分可用的时候，即对于新用户来说，系统不能提供可靠的推荐。接下来，将就采用何种策略来处理对上面提出的问题，进行介绍和讨论。更具体地，会阐述利用常识和特定领域的知识来提高内容解释的新技术。通过提供新的特征可能有助于克服传统的内容分析方式的限制，如 WordNet 或 Wikipedia 概念，帮助物品用一种更准确透明的方式进行推荐。此外，将推荐过程中用户定义词典，如大众分类，作为扩展词表加入考虑并进行整合的过程，使用惊喜度推荐，即新颖性很高的用户感兴趣的物品，来满足用户的可能方式将作为解决过度特化问题的解决方案进行分析。 3. 补充&emsp;&emsp;本篇文章只是大概写一下关于内容推荐的系统，具体的算法没有提及，日后有时间的话会不断的补充，最主要的一点是敲公式太麻烦了，此外还有基于情景感知的推荐系统以及基于约束的推荐系统日后应该不会提及，有兴趣的同学可以看一下《推荐系统：技术、评估及高效算法》，下一篇着重讲一下推荐系统中的数据挖掘方法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于近邻推荐方法综述]]></title>
    <url>%2F2018%2F07%2F01%2F1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文主要是对推荐系统中常用的常用算法的适用性以及优劣做一个总结，以让自己有一个更加清晰的认识，不会涉及公式以及算法的实现。 1 基于近邻推荐方法综述&emsp;&emsp;基于领域的推荐方法中主要包括了两种著名的推荐方法：基于用户的推荐和基于物品的推荐。在基于用户的推荐系统中，目标用户对某一物品的感兴趣程度是利用对该物品的历史评分，并且和目标用户有相似评分模式的其他用户来估计的。这里的目标用户的近邻是指与目标用户评分模式很一致的用户。基于物品的推荐系统，是根据某一用户对相似于目标物品的评分来预测该用户对目标物品的评分。在这种方法中，相似物品指那些被同一组用户评分并且评分值相近的物品。 2 基于近邻的两种推荐方法&emsp;&emsp;基于领域的推荐系统是根据相同的“口碑”的准则，根据和用户兴趣相同的人或者根据其他可信源来评价一个物品。 2.1 基于用户和基于物品的推荐方法的比较&emsp;&emsp;当需要选择是基于用户还是基于物品的推荐方法来实现推荐系统的时候，有5个准则需要考虑： 准确性 : 推荐系统的准确度很大程度依赖于系统中用户数和物品数之间的比例。通常，一小部分高可信度的用户要比一大部分相似度不是那么可信的近邻要合适的多，对于用户数量远远大于物品数量的大型商业系统，基于物品的推荐西永更加准确。同样对于用户数少与物品的推荐系统来说，可能采用基于用户的推荐系统更加准确。 效率：当用户数量远远大于物品数量时，基于物品推进方法在计算相似度权重方面所需的内存和时间要远远小于基于用户的方法，但是在线推荐阶段的时间复杂度因为只依赖于有效的物品和近邻数量的最大值，所以两者是相同的。 稳定性 稳定性主要取决于用户或者物品的改变频率和数量。 合理性 基于物品的推荐方法优点是容易证明推荐的合理性。基于用户的推荐系统就很难坐到这一点，因为用户不认识在在推荐结果中起到近邻作用的其他用户。 惊喜度 基于用户的推荐方法是根据用户的相似度来进行的，因此更有可能生成较为新颖的推荐结果，当推荐是基于很小部分近邻数更为有效。2.2 基于近邻方法的要素&emsp;&emsp;在近邻推荐系统中除了选择基于物品还是用户的推荐方法还存在一些重要属性比如:1)标准化评分;2)相似权重的计算;3)近邻的选择。2.2.1 评分标准化&emsp;&emsp;当一个用户对一个物品给予评分的时候，每个用户都有自己的评价准则。即使显示地定义每个评分的意义，有些用户依然不情愿给他们呢的物品评高分或者给他们不喜欢的物品评低分。均值中心化和Z-socre标准化可以将个人评分标准转换到更一般的整体评分标准。 均值中心化：通过与平均分的比较来决定一个评分为正或者负。 Z-score标准化：考虑个人评分范围不同带来的差异性。比如：用户 A 和用户 B 平均评分都是3，但是假设用户 A 的评分在1-5之间，用户 B 都是3。如果用户 B 给物品评5分，这会比用户 A 给物品5分更加以意外。因此反映了用户 B 更加喜欢这个物品。&emsp;&emsp;对比两者，Z-score在处理范围很大的离散评分或者连续值评分时更有优势。2.2.2 相似度权重的计算&emsp;&emsp;相似度权重计算在基于领域的推荐方法中扮演者重要的角色:1)可以选择可信的近邻用户用于评测评分；2）给予不同近邻在预测中的权重。计算相似度权重是基于近邻推荐系统中最重要的一个方面，他可以直接影响准确性和性能。具体的相似度计算方法本文略过，我们平常使用的余弦相似度扩展一下都可以。2.2.2 领域的选择2.2.2.1 领域的选择&emsp;&emsp;在大型的推荐系统中，由于硬件资源的限制，它不太可能存储所有的非零相似度。我们可以通过下边的方法来进行限制。 top-N过滤 阈值过滤 负值过滤2.2.2.2 用于预测的近邻&emsp;&emsp;一旦计算出每个用户或者物品的候选近邻列表，对一个新的评分预测可以通过k近邻方法得到，K 近邻也就是相似度权重对打的K个近邻。最重要的问题就是如何选择 K 值。&emsp;&emsp;K值的增加通常呈现出一个凸函数。因此当近邻数目限制一个很小的数的时候，预测度通常会低。当 K 很大的时候，一些重要的关联被一些不重要的关联所削弱。如何选择一个最优 K 值是我们优先考虑的问题。2.3 基于近邻的推荐方法优化&emsp;&emsp;基于近邻的推荐方法依然存在缺点： 覆盖受限：由于计算两个用户间的相似是基于他们对相同物品的评分，而且只有对相同物品进行评分的用户才可以作为近邻，所以覆盖受限。 对稀疏数据敏感：稀疏性是大多数推荐熊面临的共同问题，尤其面对冷启动问题，稀疏性更加严重。&emsp;&emsp;本文在这里列举两个方法，具体的方法和实现可以查阅相关文献: 基于图的方法 基于学习的方法]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法之路-常见字符串处理总结]]></title>
    <url>%2F2018%2F06%2F01%2F1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;字符串处理是算法中比较重要的一部分。在本篇中，主要介绍一系列常见并且重要的字符串处理算法。 1.1 易位构词 定义&emsp;&emsp;如果对调字符，使得单词 w 变成单词 v，那么 w 就是 v 的易位构词。输入一个集合包含n个最大长度为 k 的单词，输出找到所有的易位构词。&emsp;&emsp;输入: &quot;le chien marche vers sa niche et trouve une limace de chine nue pleine de malice qui lui fait du charme&quot;&emsp;&emsp;输出: [&#39;chine&#39;, &#39;niche&#39;, &#39;chien&#39;], [&#39;marche&#39;, &#39;charme&#39;], [&#39;nue&#39;, &#39;une&#39;], [&#39;limace&#39;, &#39;malice&#39;] 算法思想&emsp;&emsp;思路比较简单，对每个单词进行排序，排序相同的放在一起。值得提醒的是，如果两个单词相同，则不是易构单词。 代码实现1234567891011121314def anagrams(w): w = list(set(w.split())) #分割删除重复项 d = &#123;&#125; for i in range (len(w)): #相同标签的单词序号保存在一起 s = "".join(sorted(w[i])) if s in d: d[s].append(i) else: d[s] = [i] reponse = [] for s in d: #输出易位单词 if len(d[s]) &gt; 1: reponse.append([w[i] for i in d[s]]) return reponse 1.2 KMP算法&emsp;&emsp;KMP算法可以说是一个很经典的算法，我们在日常编程中也经常会用到，KMP算法用来解决一系列字符串单模式匹配问题以及延伸出来的最大边KMP算法等等。 定义&emsp;&emsp;给定一个长度为 n 的字符串 s 和一个长度为 m 的待匹配模式字符串 t ，我们希望找到 t 在 s 中第一次出现的下标 i 。当 t 不是 s 的子串时，返回 -1。&emsp;&emsp;复杂度 O(n+m) 算法思想&emsp;&emsp;具体的算法思路可以参考这篇博客KMP算法详解。KMP算法主要是分为两个部分，第一部分计算模式字符串的 next 。第二部分计算字符串匹配。下边代码我们把两部分放在一个函数中。 代码实现1234567891011121314151617181920212223242526def kmp(s,p): len_s = len(s) len_p = len(p) next = [0] * len_p next[0] = -1 k = -1 j = 0 while j &lt; len_p-1: if k == -1 or p[j] == p[k]: j += 1 k += 1 next[j] = k else: k = next[k] i = 0 j = 0 while i &lt; len_s and j &lt; len_p: if j == -1 or s[i] == p[j]: i += 1 j += 1 else: j = next[j] if j == len_p: return i - j else: return -1 模式匹配算法除了KMP算法之外，还有Rabin-Karp算法，有时间的话会加上Rabin-Karp算法，Rabin-Karp算法时间复杂度一般也为 O(n) 。 1.3 回文字符： Manacher 算法&emsp;&emsp;manacher算法，我们习惯叫他 “马拉车”算法。&emsp;&emsp;Manacher算法的应用范围比较狭窄，但是它的思想和拓展kmp算法有很多共通之处，所以在这里介绍一下。Manacher算法是查找一个字符串的最长回文子串的线性算法。&emsp;&emsp;首先介绍一下什么是回文串，所谓回文串，简单来说就是正着读和反着读都是一样的字符串，比如abba，noon等等，一个字符串的最长回文子串即为这个字符串的子串中，是回文串的最长的那个。&emsp;&emsp;计算字符串的最长回文字串最简单的算法就是枚举该字符串的每一个子串，并且判断这个子串是否为回文串，这个算法的时间复杂度为O(n3)的，显然无法令人满意，稍微优化的一个算法是枚举回文串的中点，这里要分为两种情况，一种是回文串长度是奇数的情况，另一种是回文串长度是偶数的情况，枚举中点再判断是否是回文串，这样能把算法的时间复杂度降为O(n2)，但是当n比较大的时候仍然无法令人满意，Manacher算法可以在线性时间复杂度内求出一个字符串的最长回文字串。 定义&emsp;&emsp;如果字符串的第一个字符等于最后一个字符，而第二个字符又等于倒数第二个字符，以此类推，那么该字符就是一个回文字符串，“最长回文字串”就是要找到一个最长字串，其中字串是一个回文字串。&emsp;&emsp;输入:aaaabcdefgfedcbaa&emsp;&emsp;输出: aabcdefgfedcbaa 算法思想&emsp;&emsp;1.预处理字符串，将字符串处理为奇数，并且防止越界给字符串两边加上不同符号。&emsp;&emsp;2.对于位置 i 我们有三种情况处理，算法详情点击马拉车算法&emsp;&emsp;3.第三步就可以愉快的写代码。 代码实现12345678910111213141516def manachers(s): if s == &quot;&quot;: return (0,1) t = &quot;^#&quot; + &quot;#&quot;.join(s) + &quot;#$&quot; id_cent = 0 mx = 0 p = [0] * len(t) for i in range(1,len(t)-1): mirror = 2 * id_cent -i p[i] = max(0, min(p[mirror],mx-i)) while t[i + 1 + p[i]] == t[i - 1 - p[i]]: p[i] += 1 if i + p[i] &gt; mx: mx,id_cent, = i + p[i],i (k,i) = (max(p),p.index(max(p))) return (s[(i-k) // 2 :(i+k) //2]) 1.4小结&emsp;&emsp;字符串的处理我只记录了这三种，相对来说马拉车算法比较难理解。其他形式字符串的处理基本都是基于这些进行变化，比如:最长字串，最长公共字串等等。后续如果有时间，会继续在本文中更新Rabin-Karp算法。碰到有意思的字符串算法题也会继续更新。]]></content>
      <categories>
        <category>算法之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>易位构词</tag>
        <tag>KMP算法</tag>
        <tag>回文字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统思维导图与架构]]></title>
    <url>%2F2018%2F05%2F06%2F1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文主要是对《推荐系统技术 评估及高效算法》以及《推荐系统实战》两本书的总结，在后续的文章中会逐渐补充详细内容。 1. 推荐系统思维导图梳理 2. 推荐引擎架构&emsp;&emsp;推荐引擎使用一种或几种用户特征，按照一种推荐策略生成一种类型物品的推荐列表。 推荐系统引擎框架主要分为三个部分： A部分负责从数据库或者缓存中拿到用户行为数据，通过分析不同行为，生成当前用户的特征向量。不过如果是使用非行为特征，就不需要使用行为提取和分析模块了。该模块的输出是用户特征向量。 B部分负责将用户的特征向量通过特征-物品相关矩阵转化为初始推荐物品列表。 C部分负责对初始的推荐列表进行过滤、排名等处理，从而生成最终的推荐结果。 推荐引擎架构图 &emsp;2.1 生成用户特征向量&emsp;&emsp;一般来说，用户的特征包括两种，一种是用户的注册信息中可以提取出来的，主要包括用户的人口统计学特征。对于使用这种特征的推荐引擎，如果内存够，可以将存储这些特征的信息直接缓存在内存中，在推荐时直接拿到用户的特征数据并生成特征向量。除了这种特征，另一种特征主要是从用户的行为中计算出来的，本节着重讨论如何生成特征。&emsp;&emsp;一个特征向量由特征以及特征的权重组成，在利用用户行为计算特征向量时需要考虑以下因素。&emsp;&emsp;用户行为的种类 &emsp;在一个网站中，用户可以对物品产生很多不同种类的行为。用户可以浏览物品、单击物品的链接、收藏物品、给物品打分、购买物品、评论物品、给物品打上不同的标签、和好友分享物品、搜索不同的关键词等。这些行为都会对物品特征的权重产生影响，但不同行为的影响不同，大多时候很难确定什么行为更加重要，一般的标准就是用户付出代价越大的行为权重越高。比如，购买物品需要用户掏钱，所以用户一定会三思而后行，因此购买行为最为重要。相反，浏览物品的网页代价很小，所以这种行为对反映用户的真实兴趣的影响很小。&emsp;&emsp;用户行为产生的时间&emsp;一般来说，用户近期的行为比较重要，而用户很久之前的行为相对比较次要。因此，如果用户最近购买过某一个物品，那么这个物品对应的特征将会具有比较高的权重。&emsp;&emsp;用户行为的次数&emsp;有时用户对一个物品会产生很多次行为。比如用户会听一首歌很多次，看一部电视剧的很多集等。因此用户对同一个物品的同一种行为发生的次数也反映了用户对物品的兴趣，行为次数多的物品对应的特征权重越高。&emsp;&emsp;物品的热门程度&emsp;如果用户对一个很热门的物品产生了行为，往往不能代表用户的个性，因为用户可能是在跟风，可能对该物品并没有太大兴趣，特别是在用户对一个热门物品产生了偶尔几次不重要的行为（比如浏览行为）时，就更说明用户对这个物品可能没有什么兴趣，可能只是因为这个物品的链接到处都是，很容易点到而已。反之，如果用户对一个不热门的物品产生了行为，就说明了用户的个性需求。因此，推荐引擎在生成用户特征时会加重不热门物品对应的特征的权重。 &emsp;2.2 特征—物品相关推荐&emsp;&emsp;对于每个特征，我们可以在相关表中存储和它最相关的N个物品的ID。在线使用的特征-物品相关表一般都不止一张。以论文之间的相关表为例，计算论文之间的相关性既可以使用提出的协同过滤算法（即如果两篇论文的读者重合度很大说明两部电视剧相似），也可以通过内容计算（比如有相同的作者、关键词、相似的标题等）。即使是协同过滤，也可以根据不同的用户行为数据得到不同的相关表。比如可以根据用户的打分行为计算论文之间的相关性，也可以根据用户的浏览行为计算论文之间的相关性。总之，对于一个推荐引擎可以在配置文件中配置很多相关表以及它们的权重，而在线服务在启动时会将这些相关表按照配置的权重相加，然后将最终的相关表保存在内存中，而在给用户进行推荐时，用的已经是加权后的相关表了。&emsp;&emsp;从上面的架构图可以看到，特征—物品相关推荐模块还可以接受一个候选物品集合。候选物品集合的目的是保证推荐结果只包含候选物品集合中的物品。它的应用场合一般是产品需求希望将某些类型的电视剧推荐给用户。比如有些产品要求给用户推荐最近一周加入的新物品，那么候选物品集合就包括最近一周新加的物品。也许有读者会奇怪，为什么不在过滤模块中将候选集合外的电视剧过滤掉，而要在相关推荐模块中处理候选物品列表？这里举一个简单的例子说明原因。首先，一般来说对于协同过滤算法计算出的相关表，每个物品都会倾向于和比较热门的物品具有较高的相似度。那么假设用户购买过物品A，候选列表中包含了物品B，A和B相关，但A比B热门。那么，一般情况下，B在A的相关物品列表中会排在靠后的位置（假设排在第10名），而A在B的相关物品列表中会排在靠前的位置（假设排在第1名）。那么，如果推荐算法是给用户推荐和A最相关的5部电视剧，那么B就不会出现在用户的推荐列表中。但是，如果算法在给定候选列表时会用一种不同的方式进行推荐，比如如果用户看过和B最相关的5部电视剧中的某一部，就将B推荐给用户，那么这种情况下B就出现在推荐列表中了。&emsp;&emsp;一般来说，如果需要在一个小的候选物品集合中给用户推荐物品，那么可以考虑上述方法。但如果是要在一个很大的候选物品集合中给用户推荐物品，那么可以考虑直接在初始推荐列表中过滤掉不在候选物品集合中物品的方法。&emsp;&emsp;特征—物品相关推荐模块除了给用户返回物品推荐列表，还需要给推荐列表中的每个推荐结果产生一个解释列表，表明这个物品是因为哪些特征推荐出来的。 &emsp;2.3 过滤模块&emsp;&emsp;在得到初步的推荐列表后，还不能把这个列表展现给用户，首先需要按照产品需求对结果进行过滤，过滤掉那些不符合要求的物品。一般来说，过滤模块会过滤掉以下物品。&emsp;&emsp;用户已经产生过行为物品&emsp;因为推荐系统的目的是帮助用户发现物品，因此没必要给用户推荐他已经知道的物品，这样可以保证推荐结果的新颖性。&emsp;&emsp;候选物品以外的物品 &emsp;候选物品集合一般有两个来源，一个是产品需求。比如在首页可能要求将新加入的物品推荐给用户，因此需要在过滤模块中过滤掉不满足这一条件的物品。另一个来源是用户自己的选择，比如用户选择了某一个价格区间，只希望看到这个价格区间内的物品，那么过滤模块需要过滤掉不满足用户需求的物品。&emsp;&emsp;某些质量很差的物品 为了提高用户的体验，推荐系统需要给用户推荐质量好的物品，那么对于一些绝大多数用户评论都很差的物品，推荐系统需要过滤掉。这种过滤一般以用户的历史评分为依据，比如过滤掉平均分在2分以下的物品。 &emsp;2.4 排名模块&emsp;&emsp;经过过滤后的推荐结果直接展示给用户一般也没有问题，但如果对它们进行一些排名，则可以更好地提升用户满意度，一般排名模块需要包括很多不同的子模块，下面将对不同的模块分别加以介绍。 新颖性 多样性 时间多样性 用户反馈]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python微信防撤回]]></title>
    <url>%2F2017%2F12%2F11%2F1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;主要通过python微信库itchat，itchat可以实现很多有意思的够不够能比如:微信防撤回，微信红包提醒，微信机器人自动回复等。有关itcht的使用可以查看更多官方文档。下方代码实现了微信防撤回功能。 python3.6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176import itchatimport sysimport timeimport reimport importlibimport osimportlib.reload(sys)from itchat.content import *msg_information = &#123;&#125;face_bug = None@itchat.msg_register([TEXT, PICTURE, FRIENDS, CARD, MAP, SHARING, RECORDING, ATTACHMENT, VIDEO], isFriendChat=True,isMpChat=True) def handle_receive_msg(msg): global face_bug msg_time_rec = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) msg_from = itchat.search_friends(userName=msg['FromUserName'])['NickName'] msg_time = msg['CreateTime'] msg_id = msg['MsgId'] msg_content = None msg_share_url = None print(msg['Type']) print(msg['MsgId']) if msg['Type'] == 'Text' or msg['Type'] == 'Friends': msg_content = msg['Text'] print(msg_content) elif msg['Type'] == "Attachment" or msg['Type'] == "Video" \ or msg['Type'] == 'Picture' \ or msg['Type'] == 'Recording': msg_content = msg['FileName'] msg['Text'](str(msg_content)) elif msg['Type'] == 'Card': msg_content = msg['RecommendInfo']['NickName'] + '的名片' if msg['RecommendInfo']['Sex'] == 1: msg_content += '性别为男' else: msg_content += '性别为女' print(msg_content) elif msg['Type'] == 'Map': x, y, location = re.search( "&lt;location x=\"(.*?)\" y=\"(.*?)\".*label=\"(.*?)\".*", msg['OriContent']).group(1, 2, 3) if location is None: msg_content = r"纬度-&gt;" + x.__str__() + " 经度-&gt;" + y.__str__() else: msg_content = r"" + location elif msg['Type'] == 'Sharing': msg_content = msg['Text'] msg_share_url = msg['Url'] print(msg_share_url) face_bug = msg_content msg_information.update( &#123; msg_id: &#123; "msg_from": msg_from, "msg_time": msg_time, "msg_time_rec": msg_time_rec, "msg_type": msg["Type"], "msg_content": msg_content, "msg_share_url": msg_share_url &#125; &#125; ) @itchat.msg_register(NOTE, isFriendChat=True, isGroupChat=True, isMpChat=True)def information(msg): if '撤回了一条消息' in msg['Content']: old_msg_id = re.search("\&lt;msgid\&gt;(.*?)\&lt;\/msgid\&gt;", msg['Content']).group(1) old_msg = msg_information.get(old_msg_id) print(old_msg) if len(old_msg_id) &lt; 11: itchat.send_file(face_bug, toUserName=msg['FromUserName']) else: msg_body = "【" \ + old_msg.get('msg_from') + " 撤回了 】\n" \ + old_msg.get("msg_type") + " 消息：" + "\n" \ + old_msg.get('msg_time_rec') + "\n" \ + r"" + old_msg.get('msg_content') if old_msg['msg_type'] == "Sharing": msg_body += "\n就是这个链接➣ " + old_msg.get('msg_share_url') itchat.send_msg(msg_body, toUserName=msg['FromUserName']) if old_msg["msg_type"] == "Picture" \ or old_msg["msg_type"] == "Recording" \ or old_msg["msg_type"] == "Video" \ or old_msg["msg_type"] == "Attachment": file = '@fil@%s' % (old_msg['msg_content']) itchat.send(msg=file, toUserName=msg['FromUserName']) os.remove(old_msg['msg_content']) msg_information.pop(old_msg_id)@itchat.msg_register([TEXT, PICTURE, FRIENDS, CARD, MAP, SHARING, RECORDING, ATTACHMENT, VIDEO], isGroupChat=True)def handle_receive_msg(msg): global face_bug msg_time_rec = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) msg_Actual_from = msg['ActualNickName'] msg_from = msg_Actual_from msg_time = msg['CreateTime'] msg_id = msg['MsgId'] msg_content = None msg_share_url = None print(msg['Type']) print(msg['MsgId']) if msg['Type'] == 'Text' or msg['Type'] == 'Friends': msg_content = msg['Text'] print(msg_content) elif msg['Type'] == "Attachment" or msg['Type'] == "Video" \ or msg['Type'] == 'Picture' \ or msg['Type'] == 'Recording': msg_content = msg['FileName'] msg['Text'](str(msg_content)) elif msg['Type'] == 'Card': msg_content = msg['RecommendInfo']['NickName'] + '的名片' if msg['RecommendInfo']['Sex'] == 1: msg_content += '性别为男' else: msg_content += '性别为女' print(msg_content) elif msg['Type'] == 'Map': x, y, location = re.search( "&lt;location x=\"(.*?)\" y=\"(.*?)\".*label=\"(.*?)\".*", msg['OriContent']).group(1, 2, 3) if location is None: msg_content = r"纬度-&gt;" + x.__str__() + " 经度-&gt;" + y.__str__() else: msg_content = r"" + location elif msg['Type'] == 'Sharing': msg_content = msg['Text'] msg_share_url = msg['Url'] print(msg_share_url) face_bug = msg_content msg_information.update( &#123; msg_id: &#123; "msg_from": msg_from, "msg_time": msg_time, "msg_time_rec": msg_time_rec, "msg_type": msg["Type"], "msg_content": msg_content, "msg_share_url": msg_share_url &#125; &#125; )@itchat.msg_register(NOTE, isGroupChat=True, isMpChat=True)def information(msg): if '撤回了一条消息' in msg['Content']: old_msg_id = re.search("\&lt;msgid\&gt;(.*?)\&lt;\/msgid\&gt;", msg['Content']).group(1) old_msg = msg_information.get(old_msg_id) print(old_msg) if len(old_msg_id) &lt; 11: itchat.send_file(face_bug, toUserName=msg['FromUserName']) else: msg_body = "【" \ + old_msg.get('msg_from') + " 群消息撤回提醒】\n" \ + " 撤回了 " + old_msg.get("msg_type") + " 消息：" + "\n" \ + old_msg.get('msg_time_rec') + "\n" \ + r"" + old_msg.get('msg_content') if old_msg['msg_type'] == "Sharing": msg_body += "\n就是这个链接➣ " + old_msg.get('msg_share_url') itchat.send_msg(msg_body, toUserName=msg['FromUserName']) if old_msg["msg_type"] == "Picture" \ or old_msg["msg_type"] == "Recording" \ or old_msg["msg_type"] == "Video" \ or old_msg["msg_type"] == "Attachment": file = '@fil@%s' % (old_msg['msg_content']) itchat.send(msg=file, toUserName=msg['FromUserName']) os.remove(old_msg['msg_content']) msg_information.pop(old_msg_id)itchat.auto_login(enableCmdQR=0, hotReload=True)itchat.run() 注：本文部分代码参考网络]]></content>
      <tags>
        <tag>python</tag>
        <tag>itchat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL性能优化]]></title>
    <url>%2F2017%2F11%2F20%2F1%2F</url>
    <content type="text"><![CDATA[1.项目中常用的MySQL优化方法1. EXPLAIN做MySQL优化，我们要善用EXPLAIN查看SQL执行计划。 type列，连接类型。一个好的SQL语句至少要达到range级别。杜绝出现all级别。 key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式。 key_len列，索引长度。rows列，扫描行数。该值是个预估值。extra列，详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。 2. SQL语句中IN包含的值不应过多MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from t where num in(1,2,3) 对于连续的数值，能用between就不要用in了；再或者使用连接来替换。 3. SELECT语句务必指明字段名称SELECT*增加很多不必要的消耗（CPU、IO、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。4. 当只需要一条数据的时候，使用limit1这是为了使EXPLAIN中type列达到const类型5. 如果排序字段没有用到索引，就尽量少排序6. 如果限制条件中其他字段没有索引，尽量少用or or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用union all或者是union（必要的时候）的方式来代替“or”会得到更好的效果。7. 尽量用union all代替unionunion和unionall的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据。8. 不使用ORDER BY RAND()1select id from `dynamic` order by rand() limit 1000; 上面的SQL语句，可优化为： 1select id from `dynamic` t1 join (select rand() * (select max(id) from `dynamic`) as nid) t2 on t1.id &gt; t2.nidlimit 1000; 9. 区分in和exists、not in和not exists1select * from 表A where id in (select id from 表B) 上面SQL语句相当于 1select * from 表A where exists(select * from 表B where 表B.id=表A.id) 区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。 关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。如何高效的写出一个替代not exists的SQL语句？原SQL语句： 1select colname … from A表 where a.id not in (select b.id from B表) 高效的SQL语句： 1select colname … from A表 Left join B表 on where a.id = b.id where b.id is null 取出的数据集是A表不在B表中的数据。A - ( A ∩ B)。 10. 使用合理的分页方式以提高分页的效率1select id,name from product limit 866613,20; 使用上述SQL语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。SQL可以采用如下的写法： 1select id,name from product where id&gt; 866612 limit 20 11. 分段查询在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。扫描的行数成百万级以上的时候就可以使用分段查询： 12. 避免在where子句中对字段进行null值判断对于null的判断会导致引擎放弃使用索引而进行全表扫描。 13. 不建议使用%前缀模糊查询例如 LIKE“%name” 或者 LIKE“%name%” ，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。那如何查询%name%？答案：使用全文索引。在我们查询中经常会用到select id,fnum,fdst from dynamic_201606 where user_name like ‘%zhangsan%’; 。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。创建全文索引的SQL语法是： 1ALTER TABLE `dynamic_201606` ADD FULLTEXT INDEX `idx_user_name` (`user_name`); 使用全文索引的SQL语句是： 1select id,fnum,fdst from dynamic_201606 where match(user_name) against(&apos;zhangsan&apos; in boolean mode); 注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别。 14. 避免在where子句中对字段进行表达式操作比如： 1select user_id,user_project from user_base where age*2=36; 中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成： 1select user_id,user_project from user_base where age=36/2; 15. 避免隐式类型转换where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型。 16. 对于联合索引来说，要遵守最左前缀法则举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面。 17. 必要时可以使用force index来强制查询走某个索引有的时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用forceindex来强制优化器使用我们制定的索引。 18. 注意范围查询语句对于联合索引来说，如果存在范围查询，比如between、&gt;、&lt;等条件时，会造成后面的索引字段失效。 19. 关于JOIN优化LEFT JOIN A表为驱动表，INNER JOIN MySQL会自动找出那个数据少的表作用驱动表，RIGHT JOIN B表为驱动表。注意： MySQL中没有full join，可以用以下方式来解决： 1select * from A left join B on B.name = A.namewhere B.name is nullunion allselect * from B; 尽量使用inner join，避免left join：参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。 合理利用索引：被驱动表的索引字段作为on的限制字段。 利用小表去驱动大表：如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。 巧用STRAIGHT_JOIN：inner join是由MySQL选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。 转载总结自网络。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>myql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL中的控制流程函数]]></title>
    <url>%2F2017%2F11%2F18%2F1%2F</url>
    <content type="text"><![CDATA[控制流程函数 CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result …] [ELSE result] END返回当 value = compare-value 的 result CASE WHEN [condition] THEN result [WHEN [condition] THEN result …] [ELSE result] END当第一个为真值的condition出现时，返回该条件的结果，如果没有匹配的结果值，那么else后的结果将被返回，如果没有else部分，那么返回NULL。 123456mysql&gt; SELECT CASE 1 WHEN 1 THEN &apos;one&apos; WHEN 2 THEN &apos;two&apos; ELSE &apos;more&apos; END; -&gt;&quot;one&quot; mysql&gt; SELECT CASE WHEN 1&gt;0 THEN &apos;true&apos; ELSE &apos;false&apos; END; -&gt;&quot;true&quot;mysql&gt; SELECT CASE BINARY &apos;B&apos; WHEN &apos;a&apos; THEN 1 WHEN &apos;b&apos; THEN 2 END; -&gt;NULL 一个 CASE 表达式的默认返回值类型是任何返回值的兼容类型，但具体情况视其所在语境而定。如果用在字符串语境中，则返回结果为字符串类型。如果用在数字语境中，则返回结果为十进制值、实数值或整数值。 IF(expr1,expr2,expr3)如果expr1是TRUE(expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则IF()的返回值为expr2; 否则返回值则为expr3。IF()的返回值是否为数字值或字符串值，具体情况视其所在语境而定。123456mysql&gt; SELECT IF(1&gt;2,2,3); -&gt;&quot;3&quot;mysql&gt; SELECT IF(1&lt;2,&apos;yes &apos;,&apos;no&apos;); -&gt;&quot;yes&quot;mysql&gt; SELECT IF(STRCMP(&apos;test&apos;,&apos;test1&apos;),&apos;no&apos;,&apos;yes&apos;); -&gt;&quot;no&quot; 注：STRCMP(expr1,expr2) 如果字符串相同，则STRCMP（）返回0;如果第一个参数根据当前排序顺序小于第二个参数，则返回-1，否则返回1。 如果expr2或expr3中只有一个表达式是NULL值，则IF()函数的结果类型 为非NULL表达式的结果类型。expr1必须作为一个整数值进行评估，也就是说，假如你正在验证浮点值或字符串值，那么应该使用比较运算进行检验。 1234mysql&gt; SELECT IF(0.1,1,0); -&gt; 1mysql&gt; SELECT IF(0.1&lt;&gt;0,1,0); -&gt; 1 观察并对比上述语句的返回结果，发现在上述的第一个例子中，IF(0.1)的返回值为1，原因是IF(0.1)检验为真。在第二个例子中，比较检验了原始浮点值，目的是为了了解是否其为非零值，对比的结果是0.1确实不等于0，那么第一个表达式的结果就是整数1，因此返回结果为1。 IF()（这一点在其被储存到临时表时很重要）的默认返回值类型按照以下方式计算： 表达式 返回值 expr2 或 expr3 返回值为一个字符串 字符串 expr2 或 expr3 返回值为一个整数 整数 expr2 或 expr3 返回值为一个浮点值 浮点值 假如expr2和expr3都是字符串类型，且其中任何一个字符串区分大小写，则返回结果都是区分大小写。 IFNULL(expr1,expr2)假如expr1不为NULL，则 IFNULL() 的返回值为 expr1；否则其返回值为expr2。IFNULL() 的返回值是否为数字或是字符串，具体情况取决于其所使用的语境。123456mysql&gt; SELECT IFNULL(1,0); -&gt; 1mysql&gt; SELECT IFNULL(NULL,10); -&gt; 10mysql&gt; SELECT IFNULL(1/0,10); -&gt; 10.000 IFNULL(expr1,expr2)的默认结果值为两个表达式中数据类型更加“通用”的一个，顺序为STRING、REAL或 INTEGER。假设有一个表中含有该表达式，或 MySQL 必须在内存储器中储存 IFNULL() 的返回值到一个临时表中： 12CREATE TABLE tmp SELECT IFNULL(1,&apos;test&apos;) AS test；DESCRIBE tmp; 在这个例子中，测试列的类型为字符串类型CHAR(4)。 NULLIF(expr1,expr2)如果expr1 = expr2成立，那么返回值为NULL，否则返回值为expr1。这和CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END语句的原理相同。1234mysql&gt; SELECT NULLIF(1,1); -&gt; NULLmysql&gt; SELECT NULLIF(1,2); -&gt; 2 注意：如果参数不相等，则 MySQL 会评估expr1两次。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL比较函数和操作符]]></title>
    <url>%2F2017%2F11%2F17%2F1%2F</url>
    <content type="text"><![CDATA[MySQL 按照以下规则进行数值比较：本文转载自实验楼,同学们可以在实验楼《Mysql基础教程中》学习。 若函数中有一个或两个参数都是NULL，则比较运算的结果为NULL，除非是等号比较运算符&lt;=&gt;。 若同一个比较运算中的两个参数都是字符串类型，则作为字符串进行比较。 若两个参数均为整数，则按照整数进行比较。 十六进制值在不作为数字进行比较时，则按照二进制字符串处理。 假如参数中的一个为 TIMESTAMP 或 DATETIME + 数据类型，而其它参数均为常数，则在进行比较前应该将常数转为 timestamp 类型。这样做的目的是为了使 ODBC 的进行更加顺利。注意： 这不用于 IN() 中的参数 ! 为了更加可靠，在进行对比时通常使用完整的datetime/date/time字符串。 在其它情况下，参数作为浮点数（实数）进行比较。 在默认状态下，字符串比较不区分大小写，并使用现有字符集(默认为 cp1252 Latin1，同时也适用于英语)。为了达到比较的目的，可使用 CAST() 函数将某个值转为另外一种类型。使用 CONVERT() 可以将字符串值转为不同的字符集。 下面对各类操作符的使用进行示例 #后为语句答案： =等于：123mysql&gt; SELECT 1 = 0; # 0mysql&gt; SELECT &apos;0&apos; = 0; # 1mysql&gt; SELECT &apos;0.01&apos; = 0; # 0 对于行比较，(a, b) = (x, y)相当于：(a = x) AND (b = y)。 &lt;=&gt; 空值安全的等号： 这个操作符与 = 操作符执行相同的比较操作，不过在两个操作码均为 NULL 时，其返回至为 1 而不为 NULL，而当一个操作码为 NULL 时，其所得值为 0 而不为 NULL。 12mysql&gt; SELECT 1 &lt;=&gt; 1, NULL &lt;=&gt; NULL, 1 &lt;=&gt; NULL; # 1 1 0mysql&gt; SELECT 1 = 1, NULL = NULL, 1 = NULL; # 1 NULL NULL 对于行比较，(a, b) &lt;=&gt; (x, y)相当于：(a &lt;=&gt; x) AND (b &lt;=&gt; y)。 &lt;&gt; 或 != 不等于：123mysql&gt; SELECT &apos;.01&apos; &lt;&gt; &apos;0.01&apos;; # 1mysql&gt; SELECT .01 &lt;&gt; &apos;0.01&apos;; # 0myql&gt; SELECT &apos;zapp&apos; &lt;&gt; &apos;zappp&apos;; # 1 对于行比较，(a, b) &lt;&gt; (x, y)相当于：(a &lt;&gt; x) OR (b &lt;&gt; y)。 &lt;= 小于等于：1mysql&gt; SELECT 0.1 &lt;= 2; # 1 对于行比较，(a, b) &lt;= (x, y)相当于：(a &lt;= x) AND (b &lt;= y)。 大于： 1mysql&gt; SELECT 2 &gt; 2; #1 对于行比较，(a, b) &gt; (x, y)相当于：(a &gt; x) AND (b &gt; y)。 IS boolean_value 和 IS NOT boolean_value：根据一个布尔值来检验一个值，在这里，布尔值可以是 TRUE、FALSE 或 UNKNOWN。 12345mysql&gt; SELECT 1 IS TRUE, 0 IS FALSE, NULL IS UNKNOWN; # 1 1 1mysql&gt; SELECT 1 IS NOT UNKNOWN, 0 IS NOT UNKNOWN, NULL IS NOT UNKNOWN; # 1 1 0mysql&gt; SELECT 1 IS NULL, 0 IS NULL, NULL IS NULL; # 0 0 1mysql&gt; SELECT 1 IS NOT NULL, 0 IS NOT NULL, NULL IS NOT NULL; # 1 1 0 expr BETWEEN min AND max 假如 expr 大于或等于 min 且 expr 小于或等于 max, 则 BETWEEN 的返回值为 1，否则是 0。若所有参数都是同一类型，则上述关系相当于表达式 ： min &lt;= expr AND expr &lt;= max。其它类型的转换 根据本章开篇所述规律进行，且适用于 3 种参数中任意一种。 123mysql&gt; SELECT 1 BETWEEN 2 AND 3; # 0mysql&gt; SELECT &apos;b&apos; BETWEEN &apos;a&apos; AND &apos;c&apos;; # 1mysql&gt; SELECT 2 BETWEEN 2 AND &apos;3&apos;; # 1 expr NOT BETWEEN min AND max 这相当于 NOT(expr BETWEEN min AND max)。 COALESCE(value,…) 返回参数列表当中的第一个非 NULL 值，在没有非 NULL 值的情况下返回值为NULL。 12mysql&gt; SELECT COALESCE(NULL,1); # 1mysql&gt; SELECT COALESCE(NULL,NULL,NULL); # NULL GREATEST(value1,value2,…) 当有2个或2个以上参数时，返回值为最大(最大值的)参数。比较参数所依据的规律同LEAST()相同。 12mysql&gt; SELECT GREATEST(2,0); # 2mysql&gt; SELECT GREATEST(&apos;B&apos;,&apos;A&apos;,&apos;C&apos;); # C 在所有参数为NULL的情况下，GREATEST()的返回值为NULL。 expr IN (value,…)若expr为IN列表中的任意一个值，则其返回值为1, 否则返回值为0。假如所有的值都是常数，则其计算和分类根据 expr的类型进行。这时，使用二分搜索来搜索信息。如果IN值列表全部由常数组成，则意味着IN的速度非常快。如果expr是一个区分大小写的字符串表达式，则字符串比较也按照区分大小写的方式进行。12mysql&gt; SELECT 2 IN (0,3,5,&apos;wefwf&apos;); # 0mysql&gt; SELECT &apos;wefwf&apos; IN (0,3,5,&apos;wefwf&apos;); # 1 IN列表中所列值的个数仅受限于max_allowed_packet值。为了同SQL标准相一致，在左侧表达式为NULL的情况下，或是表中找不到匹配项或是表中一个表达式为NULL的情况下，IN的返回值均为NULL。 ()语法也可用于书写某些类型的子查询。 expr NOT IN (value,…)这与NOT (expr IN (value,…))相同。ISNULL(expr)如果expr为NULL，那么ISNULL()的返回值为1，否则返回值为0。 12mysql&gt; SELECT ISNULL(1+1); # 0mysql&gt; SELECT ISNULL(1/0); # 1 通常使用ISNULL()来判断一个值是否为NULL。（使用=比较符对比一个值与NULL值是错误的）。 INTERVAL(N,N1,N2,N3,…)假如N &lt; N1，则返回值为0；假如N &lt; N2 等，则返回值为1；假如N为NULL，则返回值为-1。所有的参数均按照整数处理。为了这个函数的正确运行，必须满足N1 &lt; N2 &lt; N3 &lt; ……&lt; Nn 。其原因是使用了二分查找。123mysql&gt; SELECT INTERVAL(23, 1, 15, 17, 30, 44, 200); # 3mysql&gt; SELECT INTERVAL(10, 1, 10, 100, 1000); # 2mysql&gt; SELECT INTERVAL(22, 23, 30, 44, 200); # 1]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL基础操作补充]]></title>
    <url>%2F2017%2F11%2F16%2F1%2F</url>
    <content type="text"><![CDATA[1. LAST_INSERT_ID()自动返回最后一个INSERT或 UPDATE 问询为 AUTO_INCREMENT列设置的第一个 发生的值。 1mysql&gt; SELECT LAST_INSERT_ID(） 产生的ID 每次连接后保存在服务器中。这意味着函数向一个给定客户端返回的值是该客户端产生对影响AUTO_INCREMENT列的最新语句第一个 AUTO_INCREMENT值的。这个值不能被其它客户端影响，即使它们产生它们自己的 AUTO_INCREMENT值。这个行为保证了你能够找回自己的 ID 而不用担心其它客户端的活动，而且不需要加锁或处理。（因为last_insert_id是针对connection的）假如你使用一个非“magic”值来更新某一行的AUTO_INCREMENT 列，则LAST_INSERT_ID() 的值不会变化(换言之, 一个不是 NULL也不是 0的值)。重点: 假如你使用单INSERT语句插入多个行， LAST_INSERT_ID() 只返回插入的第一行产生的值。其原因是这使依靠其它服务器复制同样的 INSERT语句变得简单。 2。 Mysql删除数据后更新自增idalter table table_name AUTO_INCREMENT=n 3. 计算每月的访问量下面使用BIT_COUNT函数计算每个月中某用户访问网页的天数： 12CREATE TABLE t1 (year YEAR(4), month INT(2) UNSIGNED ZEROFILL,day INT(2) UNSIGNED ZEROFILL);INSERT INTO t1 VALUES(2000,1,1),(2000,1,20),(2000,1,30),(2000,2,2),(2000,2,23),(2000,2,23); 上述建立的表中有用户访问网页的年月日，可以使用以下语句查询每个月的访问天数： 1SELECT year,month,BIT_COUNT(BIT_OR(1&lt;&lt;day)) AS days FROM t1 GROUP BY year,month;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL中用户变量和系统变量]]></title>
    <url>%2F2017%2F11%2F16%2F1%2F</url>
    <content type="text"><![CDATA[1. MYSQL中的用户变量和系统变量1.1 用户变量可以先在用户变量中保存值然后在以后引用它；这样可以将值从一个语句传递到另一个语句。用户变量与连接有关。也就是说，一个客户端定义的变量不能被其它客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放。用户变量的形式为@var_name，其中变量名var_name可以由当前字符集的文字数字字符、‘.’、‘_’和‘$’组成。 默认字符集是cp1252 (Latin1)。可以用mysqld的–default-character-set选项更改字符集，用户变量名对大小写不敏感。设置用户变量的两种语句形式 12SET @var_name = expr [, @var_name = expr] ...SELECT @var_name := expr [, @var_name = expr] ... 对于 SET，可以使用=或:=作为分配符。分配给每个变量的expr可以为整数、实数、字符串或者NULL值。对于 SELECR，分配符必须为:=而不能用=，因为在非SET语句中=被视为一个比较 操作符。注: 在 SELECT 语句中，表达式发送到客户端后才进行计算。这说明在 HAVING、GROUP BY 或者 ORDER BY 子句中，不能使用包含 SELECT 列表中所设的变量的表达式。 1.2 系统变量MySQL可以访问许多系统和连接变量。当服务器运行时许多变量可以动态更改。这样通常允许你修改服务器操作而不需要停止并重启服务器。 mysqld服务器维护两种变量。全局变量影响服务器整体操作。会话变量影响具体客户端连接的操作。 当服务器启动时，它将所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中指定的选项进行更改。服务器启动后，通过连接服务器并执行SET GLOBAL var_name语句，可以动态更改这些全局变量。要想更改全局变量，必须具有SUPER权限。 服务器还为每个连接的客户端维护一系列会话变量。在连接时使用相应全局变量的当前值对客户端的会话变量进行初始化。对于动态会话变量，客户端可以通过SET SESSION var_name语句更改它们。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其它客户端的会话变量。 对于全局变量的更改可以被访问该全局变量的任何客户端看见。然而，它只影响更改后连接的客户的从该全局变量初始化的相应会话变量。不影响目前已经连接的客户端的会话变量(即使客户端执行SET GLOBAL语句也不影响)。 可以使用几种语法形式来设置或检索全局或会话变量。下面的例子使用了sort_buffer_sizeas作为示例变量名。要想设置一个GLOBAL变量的值，使用下面的语法： 12mysql&gt; SET GLOBAL sort_buffer_size=value;mysql&gt; SET @@global.sort_buffer_size=value; 要想设置一个SESSION变量的值，使用下面的语法： 123mysql&gt; SET SESSION sort_buffer_size=value;mysql&gt; SET @@session.sort_buffer_size=value;mysql&gt; SET sort_buffer_size=value; LOCAL是SESSION的同义词。 如果设置变量时不指定GLOBAL、SESSION或者LOCAL，默认使用SESSION。要想检索一个GLOBAL变量的值，使用下面的语法： 12mysql&gt; SELECT @@global.sort_buffer_size;mysql&gt; SHOW GLOBAL VARIABLES like &apos;sort_buffer_size&apos;; 要想检索一个SESSION变量的值，使用下面的语法： 123mysql&gt; SELECT @@sort_buffer_size;mysql&gt; SELECT @@session.sort_buffer_size;mysql&gt; SHOW SESSION VARIABLES like &apos;sort_buffer_size&apos;; 这里，LOCAL也是SESSION的同义词。当你用SELECT @@var_name搜索一个变量时(也就是说，不指定global.、session.或者local.)，MySQL返回SESSION值（如果存在），否则返回GLOBAL值。对于SHOW VARIABLES，如果不指定GLOBAL、SESSION或者LOCAL，MySQL返回SESSION值。当设置GLOBAL变量需要GLOBAL关键字但检索时不需要它们的原因是防止将来出现问题。如果我们移除一个与某个GLOBAL变量具有相同名字的SESSION变量，具有SUPER权限的客户可能会意外地更改GLOBAL变量而不是它自己的连接的SESSION变量。如果我们添加一个与某个GLOBAL变量具有相同名字的SESSION变量，想更改GLOBAL变量的客户可能会发现只有自己的SESSION变量被更改]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql中的DELIMITER详解]]></title>
    <url>%2F2017%2F11%2F16%2F1%2F</url>
    <content type="text"><![CDATA[MYSQL中的delimiter详解命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。如输入下面的语句mysql&gt; select * from test_table;然后回车，那么MySQL将立即执行该语句。但有时候，不希望MySQL这么做。在为可能输入较多的语句，且语句中包含有分号。如下： 12345678910111213141516171819202122232425262728CREATE DATABASE test_db;USE test_db;CREATE TABLE test1(a1 INT);CREATE TABLE test2(a2 INT);CREATE TABLE test3(a3 INT NOT NULL AUTO_INCREMENT PRIMARY KEY);CREATE TABLE test4( a4 INT NOT NULL AUTO_INCREMENT PRIMARY KEY, b4 INT DEFAULT 0);DELIMITER |CREATE TRIGGER testref BEFORE INSERT ON test1 FOR EACH ROW BEGIN INSERT INTO test2 SET a2 = NEW.a1; DELETE FROM test3 WHERE a3 = NEW.a1; UPDATE test4 SET b4 = b4 + 1 WHERE a4 = NEW.a1; END|DELIMITER ;INSERT INTO test3 (a3) VALUES (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL);INSERT INTO test4 (a4) VALUES (0), (0), (0), (0), (0), (0), (0), (0), (0), (0); 上面就是，先将分隔符设置为 |直到遇到下一个 |,才整体执行语句。执行完后，我们使用 delimiter ; 将mysql的分隔符重新设置为分号；如果不修改，本次会话都会以 | 结束运行。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL基础操作总结（二）]]></title>
    <url>%2F2017%2F11%2F15%2F1%2F</url>
    <content type="text"><![CDATA[1. 数据库表的修改以及删除删除数据库 1DROP DATABASE &lt;数据库名字&gt;; 删除数据库中的表 1DROP TABLE &lt;表名字&gt;; 修改表的名字 1RENAME TABLE &lt;原名&gt; TO &lt;新名字&gt;; 表中新增加一列 1ALTER TABLE &lt;表名字&gt; ADD &lt;列名字&gt; &lt;数据类型&gt; &lt;约束&gt;; 具体增加到某一列后边使用after关键字 1ALTER TABLE &lt;表名字&gt; ADD &lt;列名字&gt; &lt;数据类型&gt; &lt;约束&gt; after &lt;某一列&gt;; 增加第一列后边使用first关键字 1ALTER TABLE &lt;表名字&gt; ADD &lt;列名字&gt; &lt;数据类型&gt; &lt;约束&gt; first; 修改数据类型 1ALTER TABLE &lt;表名字&gt; MODIFY &lt;列名字&gt; &lt;新数据类型&gt;; 修改表中某个值 1UPDATE &lt;表名字&gt; SET &lt;列1=值1&gt;,&lt;列2=值2&gt; WHERE &lt;条件&gt;; 删除一行记录 1DELETE FROM &lt;表名字&gt; WHERE &lt;条件&gt;; 2. 其他基本操作视图：视图是从一个或多个表中导出来的表，是一种虚拟存在的表。它就像一个窗口，通过这个窗口可以看到系统专门提供的数据，这样，用户可以不用看到整个数据库中的数据，而只关心对自己有用的数据。创建视图 1CREATE VIEW &lt;视图名(列a,列b,列c)&gt; AS SELECT &lt;列1&gt;,&lt;列2&gt;,&lt;列3&gt; FROM &lt;表名字&gt; where &lt;条件&gt;; 纯数据文件导入：文件中将包含与数据表字段相对应的多条数据，这样可以快速导入大量数据。 1LOAD DATA INFILE &lt;文件路径和文件名&gt; INTO TABLE &lt;表名字&gt;; 注：由于导入导出大量数据都属于敏感操作，根据 mysql 的安全策略，导入导出的文件都必须在指定的路径下进行，在 mysql 终端中查看路径变量： 1show variables like &apos;%secure%&apos;; SQL 语句导入，语法为：source *.sql不同点：数据文件导入方式只包含数据，导入规则由数据库系统完成；SQL 文件导入相当于执行该文件中包含的 SQL 语句，可以实现多种操作，包括删除，更新，新增，甚至对数据库的重建。导出:与导入是相反的过程，是把数据库某个表中的数据保存到一个文件之中。导出语句基本格式为： 1SELECT 列1，列2 INTO OUTFILE &apos;文件路径和文件名&apos; FROM 表名字; 数据库备份 12mysqldump -u root 数据库名&gt;备份文件名; #备份整个数据库mysqldump -u root 数据库名 表名字&gt;备份文件名; #备份整个表 注：是在终端进行备份，不是在mysql中。数据库恢复第一种方法 123source \*.sql ``` **数据库恢复第二种方法** CREATE DATABASE shujuku; #新建一个名为shujuku的数据库 #再次 Ctrl+D 退出 MySQL：mysql -u root shujuku &lt; bak.sql #数据恢复到shujuku数据库 ## 3. 补充 还有一部分关于子查询，连接查询的，建议大家阅读这个博客[mysql子查询](https://www.cnblogs.com/chiangchou/p/mysql-3.html)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL问题记录]]></title>
    <url>%2F2017%2F11%2F14%2F1%2F</url>
    <content type="text"><![CDATA[记录一个蠢蠢的问题在导入数据集的时候发现了如下一个error 1ERROR 1406 (22001): Data too long for column Google了好久，在 stackoverflow 找到了一个靠谱的答案，如下：暗自开心的按照教程改了一，结果完全没用，又走上了漫长的谷歌道路，改字符编码啊等等……吃饭的时候脑子闪过一个念头会不会是编辑器的问题啊。 在排查的过程中果然是，在vim下编辑会因为配置问题把TAB全部转换了成空格，mysql分隔符使用的是“TAB”,自然就报错。最后在补充一个知识点可以使用 FIELDS TERMINATED BY LINES TERMINATED BY关键字进行导入数据]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL基础操作总结（一）]]></title>
    <url>%2F2017%2F11%2F13%2F1%2F</url>
    <content type="text"><![CDATA[本文是对mysql基础操作的一个简单总结，同学们，可以点击这个链接在线实战。实验楼mysql基础教程在开始之前，例如其他编程语言一样,mysql同样有自己的数据类型,建议大家可以阅读这篇文章mysql数据类型 1. 创建并使用数据库创建数据库 1CREATE DATABASE &lt;数据库名字&gt;; 由于一个系统中可能会有多个数据库，要确定当前是对哪一个数据库操作，使用语句 123use &lt;数据库名字&gt;;&gt; 段落引用 查看当前数据库里有几张表 1show tables; 数据表示是数据库最重要的组成部分之一。一个数据库中一般会有多张表，这些各自独立的表通过建立关系被联接起来，才成为可以数据库。如下便是一张表：| 项目 | 价格 | 数量 || :——: | :—-: | :—-: || 01 | xiaoma | 110 || 02 | xiaohu | 112 || 03 | xiaozhang | 123 |在数据库中新建一张表的语句格式为： 123456CREATE TABLE 表的名字(列名a 数据类型(数据长度),列名b 数据类型(数据长度)，列名c 数据类型(数据长度)); 查看新建表中的内容 1SELECT * FROM &lt;数据表的名字&gt;; 使用语句向表中插入数据 1INSERT INTO 表的名字(列名a,列名b,列名c) VALUES(值1,值2,值3); 2. mysql的约束约束是一种限制，通过对表的行或列做出数据限制，来确保数据的完整性，唯一性等。 2.1 约束的种类 主键 PRIMARY KEY 默认值 DEFAULT 唯一 UNIQUE 外键 FOREIGN KEY 非空 NOT NULL2.1.1 主键约束主键 (PRIMARY KEY)是用于约束表中的一行，作为这一行的唯一标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要，主键不能有重复记录且不能为空。给某个字段添加主键约束之后，该字段不能重复也不能为空，效果和”not nullunique”约束相同，但是本质不同。主键约束除了可以做到”not null unique”之外，还会默认添加”索引”2.1.2 默认值约束DEFAULT 约束只会在使用 INSERT 语句（上一实验介绍过）时体现出来， INSERT 语句中，如果被 DEFAULT 约束的位置没有值，那么这个位置将会被 DEFAULT 的值填充。使用场景:默认值经常会使用在一些可有可无的字段，比如个性签名中，如果没有数据就会默认为空或者一个默认的文本2.1.2 唯一约束唯一约束 (UNIQUE) 比较简单，它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的。2.1.3 外键约束若有两个表A、B，id是A的主键，而B中也有id字段，则id就是表B的外键，外键约束主要用来维护两个表之间数据的一致性。一个表可以有多个外键，每个外键必须 REFERENCES(参考)另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值1foreign key&lt;classno)&gt; references t_class(cno) 上述就表示当前表中字段 classno 是和表 t_class 中字段 cno 保持一致。 2.1.4 非空约束非空约束 (NOT NULL),听名字就能理解，被非空约束的列，在插入值时必须非空。 3. 查询语句SELECT语句的基本格式 1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] 使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 使用 WHERE 语句来包含任何条件。 使用 LIMIT 属性来设定返回的记录数。 通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。where语句其中where语句后边就和我们经常编程使用的if条件语句一样。这里只总结一下: 数学符号条件：=,&lt;,&gt;,&gt;=,&lt;= “AND 与 OR” “IN 与 NOT IN”通配符在这里详细介绍一下通配符通配符语句的基本格式1WHERE column_name LIKE &apos;通配符号&apos;; %：表示任意0个或多个字符。如下，既可以查出 “s”，“stt”，“sxxx”等 1WHERE column_name LIKE &apos;s%&apos;; _ ： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句：如下，只能查出S后边带两个字符的项 1WHERE column_name LIKE &apos;s__&apos;; [字符列] ：字符列中任何一个单一字符[^字符列] 或者[!字符列]: 不在字符列中的任何一个单一字符除了上边介绍的like进行mysql模糊查询外，还有一种正则表达式模糊查询 必须使用regexp关键字。mysql中正则表达式模糊查询使用格式结果排序ORDER BY 排序关键词。默认情况下，ORDER BY 的结果是升序排列，而使用关键词 ASC 和 DESC 可指定升序或降序排序。语句格式如下 1SELECT column_name,column_name,e FROM table ORDER BY column_name DESC;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下mysql的安装问题总结]]></title>
    <url>%2F2017%2F11%2F12%2F1%2F</url>
    <content type="text"><![CDATA[1. mysql的安装 系统：Ubuntu Server 16.04.1 LTS 64位 1234#安装 MySQL 服务端sudo apt-get install mysql-server#安装 MySQL 客户端sudo apt-get install mysql-client 安装过程中自己设置root密码 12#查看是否安装成功sudo netstat -tap | grep mysql 查看是否安装成功，如果出现如下提示，则安装成功 12ubuntu@VM-0-11-ubuntu:~$ sudo netstat -tap | grep mysqltcp 0 0 localhost.localdo:mysql *:* LISTEN 25092/mysqld 使用如下两条命令，打开 MySQL 服务并使用 root 用户登录： 1234# 启动 MySQL 服务sudo service mysql start# 使用 root 用户登录，实验楼环境的密码为空，直接回车就可以登录mysql -uroot -p 在安装过程会提示输入密码，但是输入的密码没有作用，并且出现如下的错误，我把自己怎么改的教程直接贴出来，照着我的改然后重新登录就可以了。 错误:&emsp;ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; 1234567891011121314151617181920212223#使用sudo cat /etc/mysql/debian.cnf查看用户名密码ubuntu@VM-0-11-ubuntu:~$ sudo cat /etc/mysql/debian.cnf [client]host = localhostuser = debin-sys-matpassword = he5gNV6mzFoxQcsocket = /var/run/mysqld/mysqld.sock[mysql_upgrade]host = localhostuser = debin-sys-matpassword = he5gNV6mzFoxQcsocket = /var/run/mysqld/mysqld.sock用户以及密码#出现的user=debin-sys-mat是用户名，password = he5gNV6mzFoxQc为密码#用查询到的用户名以及密码登陆mysql -udebin-sys-mat -phe5gNV6mzFoxQc#注意用户名和密码之前分别有 -u和-p#用下边命令改root密码update user set authentication_string=password(&apos;要改的密码&apos;) where user=&quot;root&quot;;#mysql 新设置用户或更改密码后需用flush privileges刷新MySQL的系统权限相关表，否则会出现拒绝访问。flush privileges; 这样就安装好并且可以使用mysql。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>

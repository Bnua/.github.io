<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法之路-常见字符串处理总结]]></title>
    <url>%2F2018%2F06%2F01%2F1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;字符串处理是算法中比较重要的一部分。在本篇中，主要介绍一系列常见并且重要的字符串处理算法。 1.1 易位构词 定义&emsp;&emsp;如果对调字符，使得单词 w 变成单词 v，那么 w 就是 v 的易位构词。输入一个集合包含n个最大长度为 k 的单词，输出找到所有的易位构词。&emsp;&emsp;输入: &quot;le chien marche vers sa niche et trouve une limace de chine nue pleine de malice qui lui fait du charme&quot;&emsp;&emsp;输出: [&#39;chine&#39;, &#39;niche&#39;, &#39;chien&#39;], [&#39;marche&#39;, &#39;charme&#39;], [&#39;nue&#39;, &#39;une&#39;], [&#39;limace&#39;, &#39;malice&#39;] 算法思想&emsp;&emsp;思路比较简单，对每个单词进行排序，排序相同的放在一起。值得提醒的是，如果两个单词相同，则不是易构单词。 代码实现1234567891011121314def anagrams(w): w = list(set(w.split())) #分割删除重复项 d = &#123;&#125; for i in range (len(w)): #相同标签的单词序号保存在一起 s = "".join(sorted(w[i])) if s in d: d[s].append(i) else: d[s] = [i] reponse = [] for s in d: #输出易位单词 if len(d[s]) &gt; 1: reponse.append([w[i] for i in d[s]]) return reponse 1.2 KMP算法&emsp;&emsp;KMP算法可以说是一个很经典的算法，我们在日常编程中也经常会用到，KMP算法用来解决一系列字符串单模式匹配问题以及延伸出来的最大边KMP算法等等。 定义&emsp;&emsp;给定一个长度为 n 的字符串 s 和一个长度为 m 的待匹配模式字符串 t ，我们希望找到 t 在 s 中第一次出现的下标 i 。当 t 不是 s 的子串时，返回 -1。&emsp;&emsp;复杂度 O(n+m) 算法思想&emsp;&emsp;具体的算法思路可以参考这篇博客KMP算法详解。KMP算法主要是分为两个部分，第一部分计算模式字符串的 next 。第二部分计算字符串匹配。下边代码我们把两部分放在一个函数中。 代码实现1234567891011121314151617181920212223242526def kmp(s,p): len_s = len(s) len_p = len(p) next = [0] * len_p next[0] = -1 k = -1 j = 0 while j &lt; len_p-1: if k == -1 or p[j] == p[k]: j += 1 k += 1 next[j] = k else: k = next[k] i = 0 j = 0 while i &lt; len_s and j &lt; len_p: if j == -1 or s[i] == p[j]: i += 1 j += 1 else: j = next[j] if j == len_p: return i - j else: return -1 模式匹配算法除了KMP算法之外，还有Rabin-Karp算法，有时间的话会加上Rabin-Karp算法，Rabin-Karp算法时间复杂度一般也为 O(n) 。 1.3 回文字符： Manacher 算法&emsp;&emsp;manacher算法，我们习惯叫他 “马拉车”算法。&emsp;&emsp;Manacher算法的应用范围比较狭窄，但是它的思想和拓展kmp算法有很多共通之处，所以在这里介绍一下。Manacher算法是查找一个字符串的最长回文子串的线性算法。&emsp;&emsp;首先介绍一下什么是回文串，所谓回文串，简单来说就是正着读和反着读都是一样的字符串，比如abba，noon等等，一个字符串的最长回文子串即为这个字符串的子串中，是回文串的最长的那个。&emsp;&emsp;计算字符串的最长回文字串最简单的算法就是枚举该字符串的每一个子串，并且判断这个子串是否为回文串，这个算法的时间复杂度为O(n3)的，显然无法令人满意，稍微优化的一个算法是枚举回文串的中点，这里要分为两种情况，一种是回文串长度是奇数的情况，另一种是回文串长度是偶数的情况，枚举中点再判断是否是回文串，这样能把算法的时间复杂度降为O(n2)，但是当n比较大的时候仍然无法令人满意，Manacher算法可以在线性时间复杂度内求出一个字符串的最长回文字串。 定义&emsp;&emsp;如果字符串的第一个字符等于最后一个字符，而第二个字符又等于倒数第二个字符，以此类推，那么该字符就是一个回文字符串，“最长回文字串”就是要找到一个最长字串，其中字串是一个回文字串。&emsp;&emsp;输入:aaaabcdefgfedcbaa&emsp;&emsp;输出: aabcdefgfedcbaa 算法思想&emsp;&emsp;1.预处理字符串，将字符串处理为奇数，并且防止越界给字符串两边加上不同符号。&emsp;&emsp;2.对于位置 i 我们有三种情况处理，算法详情点击马拉车算法&emsp;&emsp;3.第三步就可以愉快的写代码。 代码实现12345678910111213141516def manachers(s): if s == &quot;&quot;: return (0,1) t = &quot;^#&quot; + &quot;#&quot;.join(s) + &quot;#$&quot; id_cent = 0 mx = 0 p = [0] * len(t) for i in range(1,len(t)-1): mirror = 2 * id_cent -i p[i] = max(0, min(p[mirror],mx-i)) while t[i + 1 + p[i]] == t[i - 1 - p[i]]: p[i] += 1 if i + p[i] &gt; mx: mx,id_cent, = i + p[i],i (k,i) = (max(p),p.index(max(p))) return (s[(i-k) // 2 :(i+k) //2]) 1.4小结&emsp;&emsp;字符串的处理我只记录了这三种，相对来说马拉车算法比较难理解。其他形式字符串的处理基本都是基于这些进行变化，比如:最长字串，最长公共字串等等。后续如果有时间，会继续在本文中更新Rabin-Karp算法。碰到有意思的字符串算法题也会继续更新。]]></content>
      <categories>
        <category>算法之路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>字符串</tag>
        <tag>易位构词</tag>
        <tag>KMP算法</tag>
        <tag>回文字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统思维导图与架构]]></title>
    <url>%2F2018%2F05%2F06%2F1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文主要是对《推荐系统技术 评估及高效算法》以及《推荐系统实战》两本书的总结，在后续的文章中会逐渐补充详细内容。 1. 推荐系统思维导图梳理 ![](images/rs.png) 2. 推荐引擎架构&emsp;&emsp;推荐引擎使用一种或几种用户特征，按照一种推荐策略生成一种类型物品的推荐列表。 推荐系统引擎框架主要分为三个部分： A部分负责从数据库或者缓存中拿到用户行为数据，通过分析不同行为，生成当前用户的特征向量。不过如果是使用非行为特征，就不需要使用行为提取和分析模块了。该模块的输出是用户特征向量。 B部分负责将用户的特征向量通过特征-物品相关矩阵转化为初始推荐物品列表。 C部分负责对初始的推荐列表进行过滤、排名等处理，从而生成最终的推荐结果。 ![](images/tuijianyinqing.png) 推荐引擎架构图 &emsp;2.1 生成用户特征向量&emsp;&emsp;一般来说，用户的特征包括两种，一种是用户的注册信息中可以提取出来的，主要包括用户的人口统计学特征。对于使用这种特征的推荐引擎，如果内存够，可以将存储这些特征的信息直接缓存在内存中，在推荐时直接拿到用户的特征数据并生成特征向量。除了这种特征，另一种特征主要是从用户的行为中计算出来的，本节着重讨论如何生成特征。&emsp;&emsp;一个特征向量由特征以及特征的权重组成，在利用用户行为计算特征向量时需要考虑以下因素。&emsp;&emsp;用户行为的种类 &emsp;在一个网站中，用户可以对物品产生很多不同种类的行为。用户可以浏览物品、单击物品的链接、收藏物品、给物品打分、购买物品、评论物品、给物品打上不同的标签、和好友分享物品、搜索不同的关键词等。这些行为都会对物品特征的权重产生影响，但不同行为的影响不同，大多时候很难确定什么行为更加重要，一般的标准就是用户付出代价越大的行为权重越高。比如，购买物品需要用户掏钱，所以用户一定会三思而后行，因此购买行为最为重要。相反，浏览物品的网页代价很小，所以这种行为对反映用户的真实兴趣的影响很小。&emsp;&emsp;用户行为产生的时间&emsp;一般来说，用户近期的行为比较重要，而用户很久之前的行为相对比较次要。因此，如果用户最近购买过某一个物品，那么这个物品对应的特征将会具有比较高的权重。&emsp;&emsp;用户行为的次数&emsp;有时用户对一个物品会产生很多次行为。比如用户会听一首歌很多次，看一部电视剧的很多集等。因此用户对同一个物品的同一种行为发生的次数也反映了用户对物品的兴趣，行为次数多的物品对应的特征权重越高。&emsp;&emsp;物品的热门程度&emsp;如果用户对一个很热门的物品产生了行为，往往不能代表用户的个性，因为用户可能是在跟风，可能对该物品并没有太大兴趣，特别是在用户对一个热门物品产生了偶尔几次不重要的行为（比如浏览行为）时，就更说明用户对这个物品可能没有什么兴趣，可能只是因为这个物品的链接到处都是，很容易点到而已。反之，如果用户对一个不热门的物品产生了行为，就说明了用户的个性需求。因此，推荐引擎在生成用户特征时会加重不热门物品对应的特征的权重。 &emsp;2.2 特征—物品相关推荐&emsp;&emsp;对于每个特征，我们可以在相关表中存储和它最相关的N个物品的ID。在线使用的特征-物品相关表一般都不止一张。以论文之间的相关表为例，计算论文之间的相关性既可以使用提出的协同过滤算法（即如果两篇论文的读者重合度很大说明两部电视剧相似），也可以通过内容计算（比如有相同的作者、关键词、相似的标题等）。即使是协同过滤，也可以根据不同的用户行为数据得到不同的相关表。比如可以根据用户的打分行为计算论文之间的相关性，也可以根据用户的浏览行为计算论文之间的相关性。总之，对于一个推荐引擎可以在配置文件中配置很多相关表以及它们的权重，而在线服务在启动时会将这些相关表按照配置的权重相加，然后将最终的相关表保存在内存中，而在给用户进行推荐时，用的已经是加权后的相关表了。&emsp;&emsp;从上面的架构图可以看到，特征—物品相关推荐模块还可以接受一个候选物品集合。候选物品集合的目的是保证推荐结果只包含候选物品集合中的物品。它的应用场合一般是产品需求希望将某些类型的电视剧推荐给用户。比如有些产品要求给用户推荐最近一周加入的新物品，那么候选物品集合就包括最近一周新加的物品。也许有读者会奇怪，为什么不在过滤模块中将候选集合外的电视剧过滤掉，而要在相关推荐模块中处理候选物品列表？这里举一个简单的例子说明原因。首先，一般来说对于协同过滤算法计算出的相关表，每个物品都会倾向于和比较热门的物品具有较高的相似度。那么假设用户购买过物品A，候选列表中包含了物品B，A和B相关，但A比B热门。那么，一般情况下，B在A的相关物品列表中会排在靠后的位置（假设排在第10名），而A在B的相关物品列表中会排在靠前的位置（假设排在第1名）。那么，如果推荐算法是给用户推荐和A最相关的5部电视剧，那么B就不会出现在用户的推荐列表中。但是，如果算法在给定候选列表时会用一种不同的方式进行推荐，比如如果用户看过和B最相关的5部电视剧中的某一部，就将B推荐给用户，那么这种情况下B就出现在推荐列表中了。&emsp;&emsp;一般来说，如果需要在一个小的候选物品集合中给用户推荐物品，那么可以考虑上述方法。但如果是要在一个很大的候选物品集合中给用户推荐物品，那么可以考虑直接在初始推荐列表中过滤掉不在候选物品集合中物品的方法。&emsp;&emsp;特征—物品相关推荐模块除了给用户返回物品推荐列表，还需要给推荐列表中的每个推荐结果产生一个解释列表，表明这个物品是因为哪些特征推荐出来的。 &emsp;2.3 过滤模块&emsp;&emsp;在得到初步的推荐列表后，还不能把这个列表展现给用户，首先需要按照产品需求对结果进行过滤，过滤掉那些不符合要求的物品。一般来说，过滤模块会过滤掉以下物品。&emsp;&emsp;用户已经产生过行为物品&emsp;因为推荐系统的目的是帮助用户发现物品，因此没必要给用户推荐他已经知道的物品，这样可以保证推荐结果的新颖性。&emsp;&emsp;候选物品以外的物品 &emsp;候选物品集合一般有两个来源，一个是产品需求。比如在首页可能要求将新加入的物品推荐给用户，因此需要在过滤模块中过滤掉不满足这一条件的物品。另一个来源是用户自己的选择，比如用户选择了某一个价格区间，只希望看到这个价格区间内的物品，那么过滤模块需要过滤掉不满足用户需求的物品。&emsp;&emsp;某些质量很差的物品 为了提高用户的体验，推荐系统需要给用户推荐质量好的物品，那么对于一些绝大多数用户评论都很差的物品，推荐系统需要过滤掉。这种过滤一般以用户的历史评分为依据，比如过滤掉平均分在2分以下的物品。 &emsp;2.4 排名模块&emsp;&emsp;经过过滤后的推荐结果直接展示给用户一般也没有问题，但如果对它们进行一些排名，则可以更好地提升用户满意度，一般排名模块需要包括很多不同的子模块，下面将对不同的模块分别加以介绍。 新颖性 多样性 时间多样性 用户反馈]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
</search>
